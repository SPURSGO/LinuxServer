
由图可见，客户端发送的本地文件名只用了8个字节，而服务端却接收了37个字节。
这就说明，在客户端发送文件名的那一次写操作之后，服务端并不是立马相对应地执行一次读操作来接收文件名.
实际的情况是：在客户端执行了多次写操作之后(即至少发送了37字节)，服务端才开始执行读操作来接收数据。
所以，服务器用这个时候读取的数据来创建文件，将会由于文件名的不合法造成创建文件失败.
文件创建失败之后，服务器程序会异常退出(此处做得不好的一点是，还没有手动关闭打开的文件描述符)。所以系统会销毁打开的文件描述符，
所以此时TCP连接断开，客户端也因此在后续发送数据时失败.

所以，我将会在客户端发送文件名之后，调用sleep()来等待服务端正确接收文件名.
也可以考虑指定一个flags值，指明文件名数据发送的方式(如：MSG_OOB。对发送/接收数据添加额外控制)。

由实验结果可以证明一个重要的原理：
即 TCP传输是面向字节流的(即提供字节流服务). （字节流概念：应用程序对数据的发送和接收是没有边界限制的）
所以造成，发送端写操作(send)的执行次数，与接收段读操作(recv)的执行次数不同.(即两者的执行次数无任何关联)。
